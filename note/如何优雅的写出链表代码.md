## 如何优雅的写出链表代码

### 一、理解指针或者引用的含义
- 含义

> 将某个变量或者对象赋值给指针（引用），实际上就是讲这个对象(变量)的地址赋值给指针（引用）。

- 示例

> p->next = q;表示p的后继指针存储了q节点的内存地址。p->next = q->next->next;表示p的后继指针存储了q节点的下一个节点的内存地址

### 二、警惕内存泄露和指针丢失（单链表）

- 插入节点

在节点a,b之间插入x,a为b的上一个节点，p指针指向节点a，则造成指针丢失和内存泄露的代码为：
```bash
p->next = x;
x->next = p->next;
```
显然这段代码会使得x指向自己，造成链表断裂，正确的代码为：
```bash
x->next = p->next;
p->next = x;
```

- 删除节点
在节点a和节点c中删除节点b，b是a的下一个节点，需要删除节点b,p指针指向节点a,代码为：
```bash
p->next = p->next->next;
```

### 三、利用“哨兵”简化实现难度

- 什么是哨兵节点？

> 链表中的哨兵节点是解决边界问题的，不参与业务逻辑。如果我们引入哨兵节点，则不管链表是否为空，head指针总是这个哨兵节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有哨兵节点的链表称为不带头链表

- 未引入哨兵节点的情况

> 如果在p节点后插入一个节点，则只需要2行代码即可搞定：

```php
new_node->next = p->next;
p->next = new_node;
```

> 但是，如果想空链表中插入一个节点，则代码如下：

```php
if(head = null){
head = new_node;
}
```

> 如果需要删除p的后继节点，一行代码即可搞定：

```php
p->next = p->next->next;
```

> 但是如果是最后一个节点(链表中只有这一个节点)则需要判断

```php
if(head->next == null){
    head = null;
}
```

- 引入哨兵节点的情况

> “哨兵节点不存在数据”，无论链表数据是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。

### 三、"哨兵"还有哪些应用场景
> 简单总结起来就是简化边界操作

### 四、重点留意边界条件处理
> 经常用来检查链表是否正确的边界的4个条件

- 如果链表为空，代码是否可以工作
- 如果链表只有一个节点时，代码是否可以正常工作
- 如果链表只包含两个节点，代码是否可以正常工作
- 代码逻辑在处理尾节点时是否能正常工作

### 五、举例画图，辅助思考
> 多画图，更加的形象，利于理解和思考，一图胜千言

### 六、多写多练，没有捷径，链表的常见操作
- 单链表反转
- 链表中的中环检测（快慢指针）
- 两个有序链表的合并
- 删除链表倒数第n个节点
- 求链表的中间节点
- 对应的leetcode上面的练习题目：206，141，21，19，876
