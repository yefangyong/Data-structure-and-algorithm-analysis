## 数组以及为什么大多数编程语言中，数组要从0开始编号，而不是从1开始

### 数组
数组是最简单的、最基础的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但是插入、删除也因为变得低效，平均时间复杂度为O(n)。

### 为什么大多数编程语言中，数组要从0开始编号，而不是从1开始
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用a来表示数组的首地址（数组名），a[0]就是偏移为0的位置，也就是首地址，
a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要这个公式：

```bash
a[k]_address = base_address + k*type_size
```
但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为：

```bash
a[k]_address = base_address + (k-1)*type_size
```
对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是非常基础的编程操作，效率的优化就要做得极致，所有为了减少一次减法操作，数组选择了从0开始编导，而不是从1开始。

上述解释可能算不上压倒性的证明，说明数组编号从0开始不可，最主要的可能是因为历史原因。

C语言设计者用0开始计数数组下标，之后的JAVA、javascript等高级语言都效仿了C语言或者说在一定程度上面较少了C程序员学习java的成本，因此继续沿用了从0开始计数的习惯。

### 数组和链表的区别

链表适合插入、删除，时间复杂度为O(1);数组适合查找，查找的时间复杂度为O(1);实际上这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为O(1),即便是排好序的数组，用二分查找，时间复杂度也是O（logn）。所以正确的表述应该是数组支持随机访问，随机访问的时间复杂度是O(1)。

