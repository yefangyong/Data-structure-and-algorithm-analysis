## 数据结构之排序[上]

### 一、几种经典的排序算法以及时间复杂度比较
#### 经典的时间排序算法
冒泡排序，选择排序，插入排序（O(n^2)）基于比较

归并排序，希尔排序(O(nlogn)) 基于比较

桶，基数，计数O(n) 不基于比较

### 二、如何分析一个“排序算法”

#### 排序算法的执行效率
1、最好情况，最坏情况，平均情况时间复杂度

2、时间复杂度的系数、常数、低阶

3、比较次数和交换(或移动)次数

4、稳定性：选择排序是稳定的排序算法。

#### 排序算法的内存消耗
原地排序：指空间复杂度为O(1)的排序算法

#### 排序算法的稳定性
相同的记录，在排序过后，不改变前后位置，这种排序算法叫做稳定的排序算法；如果前后位置改变，那样的排序算法叫做不稳定的排序算法。

### 三、冒泡排序算法

#### 原理
冒泡排序算法只会操作相邻的数据。每次冒泡操作都是让两个数据进行比较，看是否满足大小关系，不满足则互换位置，每次冒泡结束都会使最小或者最大的数据在最前面的位置。

#### 实现过程

```php
function sortArr($array = array()){
    $n = count($array);
    if($n <= 1){
        return $array;
    }
    for($i = 0;$i<$n;$i++){
    //标志位，优化算法，减少循环次数
        $flag = false;
        for($j = 0;$j<$n-$i-1;$j++){
            if($array[$j] < $array[$j+1]){
                $tmp = $array[$j];
                $array[$j] = $array[$j+1];
                $array[$j+1] = $tmp;
                $flag = true;
            }
        }
        if(!$flag){
            break;
        }
    }
    return $array;
}
```
#### 性能分析
1、最好情况（满有序度）：O(n)。

2、最坏情况(满逆序度):O(n^2)。

3、平均时间复杂度：“有序度”和“逆序度”：对于一个不完全有序的数组，如4，5，6，3，2，1，有序元素对为3个（4，5），（4，6），（5，6），有序度为3，逆序度为12；对于一个完全有序的数组，如1，2，3，4，5，6，有序度就是n*(n-1)/2，也就是15，称作满有序度；逆序度=满有序度-有序度；冒泡排序、插入排序交换（或移动）次数=逆序度。
最好情况下初始有序度为n*(n-1)/2，最坏情况下初始有序度为0，则平均初始有序度为n*(n-1)/4，即交换次数为n*(n-1)/4，因交换次数<比较次数<最坏情况时间复杂度，所以平均时间复杂度为O(n^2)。

4、稳定性：选择排序是稳定的排序算法。
### 四、插入排序

#### 原理
插入排序把数组分为有序区和无序区，每次从无序区中选出一个数据，跟有序区的数据进行比较，找出应该插入的位置，进行插入，直到无序区的数据为空为止。

#### 实现过程
```php
function insertSort($array = array()){
    $n = count($array);
    if($n <= 1){
        return $array;
    }
    for($i = 0;$i<$n;$i++){
        $value = $array[$i];
        $j = $i-1;
        for(;$j<=0;$j--){
            if($array[$j] < $value){
                $array[$j+1] = $value;
            }else{
                break;
            }
        }
        $array[$j+1] = $value;
    }
    return $array;
}
```
#### 性能分析
1、最好情况（满有序度）：O(n)。

2、最坏情况(满逆序度):O(n^2)。

3、平均时间复杂度:O(n^2)

### 五、选择排序

#### 原理
选择排序和插入排序一样，把数据分为有序区和无序区，每次循环从无序区中找到最小的元素，和第i的记录互换

#### 实现过程
```php
function selectSort($array = array()){
    $n = count($);
    if($n <= 1){
        return $array;
    }
    for($i = 0;$i<$n;$i++){
        $min = $i;
        for($j = $i+1;$j<$n;$j++){
            if($array[$j] < $array[$min]){
                $min = $j;
            }
        }
        if($min != $i){
            $tmp = $array[$min];
            $array[$min] = $array[$i];
            $array[$i] = $tmp;
        }
    }
    return $array;
}
```
#### 性能分析

1、最好情况（满有序度）：O(n^2)。

2、最坏情况(满逆序度):O(n^2)。

3、平均时间复杂度:O(n^2)

4、稳定性：选择排序不是稳定的排序算法。

### 六、思考：选择排序和插入排序的时间复杂度相同，都是O(n^2),在实际的软件开发中，为什么我们更加倾向于使用插入排序而不是冒泡排序算法呢？
> 从代码中看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3次赋值的操作，而排序只需要1个，所以在相同的数据进行排序时，冒泡排序的时间理论上要大于插入排序。(冒泡排序数据交换需要3次赋值，而插入排序只需要一次移动数据)

