## 数据结构之排序优化

### 一、如何选择合适的排序算法
> 回顾下前面学习的几种排序算法

|排序算法名|时间复杂度|是否稳定|是否是原地排序|
|:----    |:---|:----- |-----   |
|冒泡排序 |O(n^2)  |稳定 |是   |
|插入排序 |O(n^2)  |稳定 |是   |
|选择排序 |O(n^2)  |不稳定 |是   |
|归并排序 |O(nlogn)  |稳定 |不是   |
|快速排序 |O(nlogn) |不稳定 |是   |

> 线性排序的时间复杂度比较低，但是适用的场景比较特殊，如果写一个比较通用的排序算法，不能使用线性排序入桶排序和基数排序等等。

### 二、为什么选择快速排序？

- 线性排序的时间复杂度很低，但是使用场景特殊，如果写一个通用的排序函数，不能选择线性排序。

- 为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序算法。

- 同样时间复杂度为O(nlogn)的归并排序算法和快速排序算法，因为

### 三、如何优化选择排序算法

> 如果时间是有序的或者接近有序的，选择排序的算法时间复杂度会退化成O(n^2),主要是因为选取的分区点导致的，因此选取一个好的分区点至关重要。最理想的分区点为，两边的数据差不多，常用的分区算法为：

- 三数取中法

> 我们从区间的首，中，尾分别取出一个数据，进行比较取出三个数的中间值，作为分区点。

- 随机法

> 随机法就是每次从排序的区间中，随机选取一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能出现每次分区点都选的很差的情况，所以平均情况下，这样的分区点还是比较好的。

- 为了避免快速排序中，递归过深而堆栈过小，导致堆栈溢出的方法。

> 第一种是限制递归的深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈，出栈的过程，这样就没有了系统栈大小的限制。

### 四、举例分析排序函数
C语言中qsort()函数，**qsort函数首先优先使用归并排序来排序输入数据**，因为归并排序算法的空间复杂度为O(n)，所以对于小数据的排序，比如1KB，2KB的数据，因为归并排序需要额外的内存空间1KB,2KB,现在的计算机内存都比较大，都比较大，我们很多时候追求的是速度，这也是利用空间换时间的一个非常典型的案例。

但是如果数据量过大的时候，如果排序100MB的数据的时候，这个时候如果还使用归并排序算法就不太合适了，所以，**当数据量比较大的时候，qsort函数会使用快速排序的算法来排序**，那qsort函数是如何选取分区点的呢？qsort函数采用的是“三数取中法”。

还有递归太深会导致堆栈溢出的问题，qsort函数通过自己实现了一个堆上的栈，手动模拟递归解决的。

实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于4的时候，qsort就退化为插入排序，不再继续用递归来做快速排序，因为在小规模的数据面前，**O(n^2)时间复杂度的算法不一定比O(nlogn)的算法执行时间长**。

### 五、通用排序函数实现技巧

- 数据量不大时，可以采取用时间换空间的思路

- 数据量大时，优化快排分区点的选择

- 防止堆栈溢出，可以选择在堆上手动实现栈

- 在排序区间中，当元素小于某个常数的时候，可以考虑使用O(n^2)级别的插入排序

- 用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致