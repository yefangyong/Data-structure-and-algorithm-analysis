## 数据结构之散列表【下】

### 一、为什么散列表和链表经常放在一起使用

- 散列表的优点：支持高效的数据插入、删除和查找操作
- 散列表的缺点：不支持快速顺序遍历散列表中的数据
- 如何按照顺序快速遍历散列表的数据？只能讲数据转移到数组，然后排序，最后再遍历数据。
- 我们知道散列表是动态的数据结构，需要频繁的插入和删除数据，那么每次顺序遍历之前都需要先排序，这势必会造成效率非常低下。
- 如何解决上述的问题，就是讲散列表和链表(或跳表)结合起来使用。

### 二、散列表和链表结合起来如何使用？

#### 1、LRU(least Recently Used)缓存淘汰算法

##### 1.1 LRU缓存淘汰算法主要有哪些操作？主要包含三个操作

- 从缓存中添加一个数据；
- 从缓存中删除一个数据；
- 从缓存中查找一个数据；
- 总结：上面三个操作都涉及到查找

##### 1.2 如何用链表实现LRU缓存淘汰算法？

- 需要维护一个按照访问时间从大到小的有序排列的链表结构
- 缓存空间有限，当空间不足需要淘汰一个数据时直接删除链表头部的节点
- 当要缓存某个数据的时，先在链表中查找这个数据，若未找到，则直接将数据放到链表的尾部。若找到，就把它移动到链表的尾部。
- LRU缓存的3个主要的操作都涉及到查找，若单纯由链表实现，查找的时间复杂度很高为O(n)。若链表和散列表结合使用，查找的时间复杂度会降到O(1)。

##### 1.3 如何使用散列表和链表实现LRU缓存淘汰算法？
- 使用双向链表存储数据，链表中每个节点存储数据(data)、前驱指针(prev)、后继指针(next)和hnext指针(解决散列冲突的指针)。
- 散列表通过链表法解决散列冲突，所以每个节点都会在两条链表中。一条链式是双向链表，另一条链式散列表中的拉链。前驱和后继指针是为了将节点串在双向链中，hnext指针是为了将节点串在散列表的拉链中。
- LRU缓存淘汰算法的3个主要操作的时间复杂度为什么是O(1)呢？
> 首先，我们需要明确一点就是链表本身的插入和删除一个节点的时间复杂度为O(1),因为只需要改变几个指针的指向即可。接着，来分析查找操作的时间复杂度，当要查找一个数据的时，通过散列表可实现在O(1)的时间复杂度找到该数据，再加上前面说的插入或者删除的时间复杂度是O(1),所以我们总操作的时间复杂度就是O(1)。

#### 2、Redis有序集合

##### 2.1、什么是有序集合？
- 在有序集合中，每个成员的对象有两个重要的属性，即key和value。
- 不仅会通过value来查找数据，还需要通过key来查找数据

##### 2.2、有序集合的操作有哪些？

> 举个例子，比如用户积分排行榜有这样的一个功能，可以通过用户ID来查找积分信息，也可以通过积分区间来查找用户的ID，这里的用户ID就是key,积分就是value。所以，有序的操作如下：

- 添加一个对象
- 根据键值删除一个成员对象
- 根据键值查找一个成员对象
- 根据分值区间查找数据，比如查找积分在[1,20]之间的成员对象；
- 按照分值从小到大排序成员变量
- 这时可以按照分值将成员对象组织成跳表结构，按照键值构建一个散列表，这样上面所有的操作非常快

#### 3、Java LinkedHashMap

- 和LRU淘汰策略实现一模一样。支持按照插入顺序遍历数据，也支持按照访问顺序遍历数据。

### 三、课后思考
> 假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假如你是猎聘网的一名工程师，如何在内存中存储这10万个猎头ID和积分信息，让它能够支持这样几个操作：

- 根据猎头的ID快速查找，删除，更新这个猎头的积分信息
- 查找积分在某个区间的猎头ID列表
- 查找按照积分从小到大排名在第X位到第Y位之家的猎头ID列表

> 解决方案：积分排序构建一个跳表，再以猎头ID构建成一个散列表，可以支持上述操作。
  