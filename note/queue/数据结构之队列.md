## 数据结构之队列

### 一、如何理解“队列”

- 1、队列是一种操作受限的线性表数据结构
- 2、队列最大的特点就是先进先出
- 3、最基本的操作：入队(enqueue)和出队(dequeue)，从队列头部取一个元素

### 二、顺序队列和链式队列

- 1、用数组实现的队列叫做顺序队列，用链表实现的队列叫做链式队列。
- 2、队列需要两个指针，一个是head指针，指向队头，一个tail指针指向队尾。
- 3、随着不停的入队，出队操作，head和tail都会持续的往后移动。当tail移动到最后的右边，即使数组中还有空闲时间，也无法继续往队列中添加数据了。
- 4、实际上，我们在出队时不用搬移数据。如果没有空闲空间了，只需要在入队时，在集中触发一次数据的迁移操作。出队函数dequeue保持不变，我们稍加改造一个入队函数enqueue的实现，当队列的tail指针移动到数组的最后边，如果有新的数据入队，我们可以将head到tail之间的数据整体搬移到数组中0到tail-head的位置。
- 5、基于链表实现队列，可以动态无限扩充，同样的需要两个指针：head指针和tail指针。分别指向链表的第一个节点和最后一个节点。入队时：tail->next=new_node,tail=tail->next;出队时，head=head->next。

### 三、循环队列

- 1、循环队列，原来数组是有头有尾的，是一条直线，把首尾相连，扳成了一个环。
- 2、在数组实现队列的时候，会有数据的搬移操作，时间复杂度会变高，要想解决数据搬移的问题，需要像环一样的循环队列
- 3、要想写出没有bug的循环队列的实现代码，最关键的是，确定好队空和队满的判定条件。队空的判定条件依然是head=tail,而队满的判定条件是（tail+1)%n=head,tail执行的位置实际上是没有存储数据的，所以循环队列会浪费一个数组的存储空间


### 四、阻塞队列

- 1、阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说就是在队列为空的时候，从队头取数组会被阻塞。因为此时没有数据可取，直到队列中有了数据才能返回；如果队列已满，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。
- 2、基于阻塞队列实现的“生产者-消费者模型”，可以有效的协调生产和消费的速度。当“生产者的生成速度过快”的时候，“消费者”就来不及消费时，存储队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生成者”才会继续唤醒继续“生产”。
而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。
- 3、在工作中laravel框架中使用队列在我看来就是阻塞队列，当生产者过快的生产数据，导致队列数据积压，我们采用了提高“消费者”的个数，开启三个进程，进行消费。


### 五、并发队列

- 1、在多线程的情况下，会有多个线程同时操作队列，这时候就会存在线程安全问题。能够有效的解决线程安全问题的队列就是成为并发队列。
- 2、并打队列简单实现就是在enqueue,dequeue,方法上面加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。

### 六、线程没有空闲线程时，新的任务请求线程资源时，线程池应该如何处理？各种处理策略又是如何实现的呢？

> 一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等有空闲线程的时候，取出排队的请求继续处理。

- 1、基于链表的实现方式，可以实现一个支持无线排队的无界队列，但是可能会导致过多的请求排队等待，请求处理的响应时间过长，所以针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。
- 2、基于数组实现的有界队列，队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理，不过设置一个合理的队列大小，也是非常讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源，发挥最大的性能。

> 除了前面讲到的队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求队列。
