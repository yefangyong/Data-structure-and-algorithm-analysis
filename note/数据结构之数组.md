## 数据结构之数组
数组看似简单，但是很多人没有理解这个数据结构的精髓。
### 数组

#### 定义
数组是一种线性数据结构，用连续的存储空间存储相同的数据类型。线性结构：数组、链表、队列、栈。非线性表：树，图。

#### 数组和链表的区别
数组是适合查找，时间复杂度为O(1)，而链表适合插入，删除，时间复杂度为O(1)。实际上这种表述是不准确的，数组是适合查找操作，但是查找的时间复杂度并不为O(1),即使是排好的数组，使用二分查找，时间复杂度也是O(logn)。正确的表述：数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。

#### 低效的插入和删除

- 插入：最好O(1),最坏的O(n),平均为O(n)
- 插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把新的元素，插入到第K个位置，此处复杂度为O(1)
- 删除：从最好的O(1) 最坏的O(n) 平均O(n)

> JVM标记清楚垃圾回收算法：记录下已经被删除的数据，每次删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再真正的触发删除的操作。

#### 容器能否代替数组

相比于数字，```java```中```ArrayList```封装了很多的数组操作，并支持动态扩容。但是一旦超过存储的容量，扩容时比较耗费内存，因为涉及到内存申请和数据迁移。

#### 数组的应用场景
- java中ArrayList的使用涉及到装箱拆箱，有一定的性能损耗，可以考虑数组
- 若数组大小事先已知，并且涉及的数据操作非常简单，可以使用数组
- 表示多维数组时，数组往往更加直观
- 业务开发容器即可，底层开发，追求性能，如网络框架，优先选择数组


#### 为什么大多数编程语言中，数组要从0开始编号，而不是从1开始
从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移”（offset）。如果用a来表示数组的首地址（数组名），a[0]就是偏移为0的位置，也就是首地址，
a[k]就表示偏移k个type_size的位置，所以计算a[k]的内存地址只需要这个公式：

```bash
a[k]_address = base_address + k*type_size
```
但是，如果数组从1开始计数，那我们计算数组元素a[k]的内存地址就会变为：

```bash
a[k]_address = base_address + (k-1)*type_size
```
对比两个公式，我们不难发现，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是非常基础的编程操作，效率的优化就要做得极致，所有为了减少一次减法操作，数组选择了从0开始编导，而不是从1开始。

上述解释可能算不上压倒性的证明，说明数组编号从0开始不可，最主要的可能是因为历史原因。

C语言设计者用0开始计数数组下标，之后的```JAVA```、```javascript```等高级语言都效仿了C语言或者说在一定程度上面较少了C程序员学习java的成本，因此继续沿用了从0开始计数的习惯。




